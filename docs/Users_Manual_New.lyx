#LyX 1.4.3 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass article
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\papersize default
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The PyFITS module is a Python library providing access to FITS files.
 FITS (Flexible Image Transport System) is a portable file standard widely
 used in the astronomy community to store images and tables.
 
\end_layout

\begin_layout Subsection
Install PyFITS 
\end_layout

\begin_layout Standard
PyFITS requires Python version 2.3 or newer.
 PyFITS also requires the numarray module.
 Information about numarray can be found in:
\end_layout

\begin_layout Itemize
http://www.stsci.edu/resources/software_hardware/numarray
\end_layout

\begin_layout Standard
To download numarray, go to:
\end_layout

\begin_layout Itemize
http://sourceforge.net/project/numpy
\end_layout

\begin_layout Standard
PyFITS's source code is pure Python.
 It can be downloaded from:
\end_layout

\begin_layout Itemize
http://www.stsci.edu/resources/software_hardware/pyfits/Download
\end_layout

\begin_layout Standard
PyFITS uses python's distutils for its installation.
 To install it, unpack the tar file and type:
\end_layout

\begin_layout Quotation
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard

\emph on
python setup.py install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This will install pyfits, readgeis and fitsdiff in python's site-packages
 directory.
 If permissions do not allow this kind of installation PyFITS can be installed
 in a personal directory using one of the commands below.
 Note, that PYTHONPATH has to be set or modified accordingly.
 The three examples below show how to install PyFITS in an arbitrary directory
 <install-dir> and how to modify PYTHONPATH.
\newline

\end_layout

\begin_layout Standard

\emph on
python setup.py install --local=<install-dir> 
\end_layout

\begin_layout Standard

\emph on
setenv PYTHONPATH <install-dir>
\emph default

\newline

\end_layout

\begin_layout Standard

\emph on
python setup.py install --home=<install-dir> 
\end_layout

\begin_layout Standard

\emph on
setenv PYTHONPATH <install-dir>/lib/python
\emph default

\newline

\end_layout

\begin_layout Standard

\emph on
python setup.py install --prefix=<install-lib>
\end_layout

\begin_layout Standard

\emph on
setenv PYTHONPATH <install-dir>lib/python2.3/site-packages
\emph default

\newline

\end_layout

\begin_layout Standard
In this Guide, we'll assume that the reader has basic familiarity with Python.
 Familiarity with numarray is not required, but it will help to understand
 the data structures in PyFITS.
 
\end_layout

\begin_layout Subsection
User Support for PyFITS 
\end_layout

\begin_layout Standard
The official PyFITS web page is: 
\end_layout

\begin_layout Itemize
http://www.stsci.edu/resources/software_hardware/pyfits
\end_layout

\begin_layout Standard
If you have any question or comment regarding PyFITS, user support is available
 through the STScI Help Desk: 
\end_layout

\begin_layout Itemize
E-mail: help@stsci.edu 
\end_layout

\begin_layout Itemize
Phone: (410) 338-1082 
\end_layout

\begin_layout Section
A Quick Tutorial
\end_layout

\begin_layout Standard
This chapter provides a quick introduction of using PyFITS.
 The goal is to demonstrate PyFITS s basic features without getting into
 too much detail.
 If you are a first time user or an occasional PyFITS user, using only the
 most basic functionality, this is where you should start.
 Otherwise, it is safe to skip this chapter.
 
\end_layout

\begin_layout Standard
After installing numarray and PyFITS, start Python and load the PyFITS library.
 Note that the module name is all lower case.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> import pyfits
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Read and Update Existing FITS Files
\end_layout

\begin_layout Subsubsection
Open a FITS file
\end_layout

\begin_layout Standard
Once the PyFITS module is loaded, we can open an existing FITS file:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdulist = pyfits.open('input.fits')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
open()
\emph default
 function has several optional arguments which will be discussed in a later
 chapter.
 The default mode, as in the above example, is "readonly".
 The open method returns a PyFITS object called an HDUList which is a Python-lik
e list, consisting of HDU objects.
 An HDU (Header Data Unit) is the highest level component of the FITS file
 structure.
 So, after the above open call, hdulist[0] is the primary HDU, hdulist[1],
 if any, is the first extension HDU, etc.
 The HDUList has a useful method 
\emph on
info()
\emph default
, which summarizes the content of the opened FITS file:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdulist.info() 
\end_layout

\begin_layout Standard
Filename: test1.fits 
\end_layout

\begin_layout Standard
No.
 Name Type Cards Dimensions Format 
\end_layout

\begin_layout Standard
0 PRIMARY PrimaryHDU 220 () Int16 
\end_layout

\begin_layout Standard
1 SCI ImageHDU 61 (800, 800) Float32 
\end_layout

\begin_layout Standard
2 SCI ImageHDU 61 (800, 800) Float32 
\end_layout

\begin_layout Standard
3 SCI ImageHDU 61 (800, 800) Float32 
\end_layout

\begin_layout Standard
4 SCI ImageHDU 61 (800, 800) Float32
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After you are done with the opened file, close it with the 
\emph on
close()
\emph default
 method:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdulist.close()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The headers will still be accessable after the HDUlist is closed.
 The data may or may not be accessable depending on whether the data are
 touched and if they are memory-mapped, see later chapters for detail.
\end_layout

\begin_layout Subsubsection
Working with the Header
\end_layout

\begin_layout Standard
As mentioned earlier, each element of an HDUList is an HDU object with attribute
s of header and data, which can be used to access the header keywords and
 the data.
 The header attribute is a Header instance, another PyFITS object.
 To get the value of a header keyword, simply do (a la Python dictionaries):
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdulist[0].header['targname'] 
\end_layout

\begin_layout Standard
'NGC121' 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
to get the value of the keyword targname, which is a string 'NGC121'.
 
\end_layout

\begin_layout Standard
Although keyword names are always in upper case inside the FITS file, specifying
 a keyword name with PyFITS is case-insensitive, for user s convenience.
 If the specified keyword name does not exist, it will raise a 
\emph on
KeyError
\emph default
 exception.
 We can also get the keyword value by indexing (a la Python lists):
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdulist[0].header[27]
\end_layout

\begin_layout Standard
96
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This example returns the 28th (like Python lists, it is 0-indexed) keyword's
 value, an integer, 96.
 
\end_layout

\begin_layout Standard
Similarly, it is easy to update a keyword s value in PyFITS, either through
 keyword name or index:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> prihdr = hdulist[0].header 
\end_layout

\begin_layout Standard
>>> hdr[ targname ] = 'NGC121-a' 
\end_layout

\begin_layout Standard
>>> hdr[27] = 99
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Use the above syntax if the keyword is already present in the header.
 If the keyword might not exist and you want to add it if it doesn t, use
 the 
\emph on
update()
\emph default
 method:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> prihdr.update('observer','Edwin Hubble')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A header consists of 
\emph on
Card
\emph default
 objects (i.e.
 the 80-column card-images specified in the FITS standard).
 Each Card normally has up to three parts: key, value, and comment.
 To see the entire list of cardimages of an HDU, use the 
\emph on
ascardlist()
\emph default
 method :
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> print prihdr.ascardlist()[:3] 
\end_layout

\begin_layout Standard
SIMPLE = T / file does conform to FITS standard 
\end_layout

\begin_layout Standard
BITPIX = 16 / number of bits per data pixel 
\end_layout

\begin_layout Standard
NAXIS = 0 / number of data axes
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Only the first three cards are shown above.
 To get a list of all keywords, use the keys() method of the card list:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> prihdr.ascardlist().keys() 
\end_layout

\begin_layout Standard
['SIMPLE','BITPIX','NAXIS', ...]
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Working with Image Data
\end_layout

\begin_layout Standard
If an HDU's data is an image, the 
\emph on
data
\emph default
 attribute of the HDU object will return a numarray object.
 Refer to the numarray Manual for details of manipulating these numerical
 arrays.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> scidata = hdulist[1].data
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, scidata points to the data object in the second HDU (the first HDU,
 
\emph on
hdulist[0]
\emph default
, being the primary HDU) in 
\emph on
hdulist
\emph default
, which corresponds to the 
\emph on
'SCI'
\emph default
 extension.
 Alternatively, you can access the extension by its extension name (specified
 in the 
\emph on
EXTNAME
\emph default
 keyword):
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> scidata = hdulist['SCI'].data
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Standard
If there is more than one extension with the same 
\emph on
EXTNAME, EXTVER's
\emph default
 value needs to be specified as the second argument, e.g.: 
\emph on
hdulist['sci',2]
\emph default
.
\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Standard
The returned numarray object has many attributes and methods for a user
 to get information about the array, e.
 g.:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> scidata.shape
\end_layout

\begin_layout Standard
(800, 800) 
\end_layout

\begin_layout Standard
>>> scidata.type() 
\end_layout

\begin_layout Standard
Float32
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since image data is a numarray object, we can slice it, view it, and perform
 mathematical operations on it.
 To see the pixel value at x=5, y=2:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> print scidata[1,4]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that, like C (and unlike FORTRAN), Python is 0-indexed and the indices
 have the slowest axis first and fast axis last, i.e.
 for a 2-D image, the fast axis (X-axis) which corresponds to the FITS NAXIS1
 keyword, is the second index.
 Similarly, the sub-section of x=11 to 20 (inclusive) and y=31 to 40 (inclusive)
 is:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> scidata[30:40, 10:20]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To update the value of a pixel or a sub-section:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> scidata[30:40,10:20] = scidata[1,4] = 999
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This example changes the values of both the pixel [1,4] and the sub-section
 [30:40,10:20] to the new value of 999.
\end_layout

\begin_layout Standard
Next example of array arithmetics is to convert the image data from counts
 to flux:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> photflam = hdulist[1].header[ photflam ] 
\end_layout

\begin_layout Standard
>>> exptime = prihdr[ exptime ] 
\end_layout

\begin_layout Standard
>>> scidata *= photflam / exptime
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This example performs the math on the array in-place, thereby keeping the
 memory usage to a minimum.
 (Note: before Python 2.2.3, the use of "*=" may cause an error, this is fixed
 in later Python versions.) 
\end_layout

\begin_layout Standard
If at this point you want to preserve all the changes you made and write
 it to a new file, you can use the 
\emph on
writeto()
\emph default
 method of HDUList (see below).
\end_layout

\begin_layout Subsubsection
Working with Table Data
\end_layout

\begin_layout Standard
If you are familiar with the record array in numarray, you will find the
 table data is basically a record array with some extra properties.
 But familiarity with record arrays is not a prerequisite for this Guide.
 
\end_layout

\begin_layout Standard
Like images, the data portion of a FITS table extension is in the 
\emph on
.data
\emph default
 attribute:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdulist = pyfits.open('table.fits') 
\end_layout

\begin_layout Standard
>>> tbdata = hdulist[1].data # assuming the first extension is a table
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To see the first row of the table:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> print tbdata[0] 
\end_layout

\begin_layout Standard
(1, 'abc',3.7000002861022949,0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each 
\emph on
row
\emph default
 in the table is a Record object which looks like a (Python) tuple containing
 elements of heterogeneous data types.
 In this example: an integer, a string, a floating point number, and a Boolean
 value.
 So the table data are just an array of such Records.
 More commonly, a user is likely to access the data in a 
\emph on
column-wise
\emph default
 way.
 This is accomplished by using the 
\emph on
field()
\emph default
 method.
 To get the first 
\emph on
column
\emph default
 (or 
\emph on
field
\emph default
) of the table, use:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> tbdata.field(0)
\end_layout

\begin_layout Standard
array([1, 2])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A numarray object with the data type of the specified field is returned.
\end_layout

\begin_layout Standard
Like header keywords, a field can be referred either by index, as above,
 or by name:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> tbdata.field('id') 
\end_layout

\begin_layout Standard
array([1, 2])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But how do we know what field names we ve got? First, let's introduce another
 attribute of the table HDU: the 
\emph on
.columns
\emph default
 attribute:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> cols = hdulist[1].columns
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This attribute is a 
\emph on
ColDefs
\emph default
 (column definitions) object.
 If we use its 
\emph on
info()
\emph default
 method:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> cols.info() 
\end_layout

\begin_layout Standard
name: 
\end_layout

\begin_layout Standard
['c1','c2','c3','c4'] 
\end_layout

\begin_layout Standard
format: 
\end_layout

\begin_layout Standard
['1J','3A','1E','1L'] 
\end_layout

\begin_layout Standard
unit: 
\end_layout

\begin_layout Standard
[ '', '', '', ''] 
\end_layout

\begin_layout Standard
null: 
\end_layout

\begin_layout Standard
[-2147483647, '', '', ''] 
\end_layout

\begin_layout Standard
bscale: 
\end_layout

\begin_layout Standard
[ '', '', 3, ''] 
\end_layout

\begin_layout Standard
bzero: 
\end_layout

\begin_layout Standard
[ '', '', 0.40000000000000002, ''] 
\end_layout

\begin_layout Standard
disp: 
\end_layout

\begin_layout Standard
[ 'I11' , 'A3' , 'G15.7' , 'L6' ] 
\end_layout

\begin_layout Standard
start: 
\end_layout

\begin_layout Standard
[ '', '', '', ''] 
\end_layout

\begin_layout Standard
dim: 
\end_layout

\begin_layout Standard
[ '', '', '', '']
\end_layout

\end_inset


\end_layout

\begin_layout Standard
it will show all its attributes, such as names, formats, bscales, bzeros,
 etc.
 We can also get these properties individually, e.g.:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> cols.names 
\end_layout

\begin_layout Standard
[ 'ID' , 'name' , 'mag' , 'flag' ]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
returns a (Python) list of field names.
 
\end_layout

\begin_layout Standard
Since each field is a numarray object, we ll have the entire arsenal of
 numarray tools to use.
 We can reassign (update) the values:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> tbdata.field( 'flag' )[:] = 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
info()
\emph default
 method of table data will show the attributes of the record array, many
 of them may seem esoteric to casual users:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> tbdata.info() 
\end_layout

\begin_layout Standard
class: <class pyfits.FITS_rec > 
\end_layout

\begin_layout Standard
shape: (2,) 
\end_layout

\begin_layout Standard
strides: (12,) 
\end_layout

\begin_layout Standard
byteoffset: 0 
\end_layout

\begin_layout Standard
bytestride: 12 
\end_layout

\begin_layout Standard
itemsize: 12 
\end_layout

\begin_layout Standard
aligned: 0 
\end_layout

\begin_layout Standard
contiguous: 1 
\end_layout

\begin_layout Standard
buffer: <memory at 0x092dc3d8 with size:0x00000018 held by 
\end_layout

\begin_layout Standard
object 0x4086eb20 aliasing object 0x00000000> 
\end_layout

\begin_layout Standard
data pointer: 0x092dc3d8 (DEBUG ONLY) 
\end_layout

\begin_layout Standard
field names: [ 'c1' , 'c2' , 'c3' , 'c4 '] 
\end_layout

\begin_layout Standard
field formats: [ '1Int32' , '1a3' , '1Float32' , '1Int8' ]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Create New FITS Files
\end_layout

\begin_layout Subsubsection
Save Changes
\end_layout

\begin_layout Standard
As mentioned earlier, after a user opened a file, made a few changes to
 either header or data, the user can use the 
\emph on
writeto()
\emph default
 method in 
\emph on
HDUList
\emph default
 to save the changes.
 This takes the version of headers and data in memory and writes them to
 a new FITS file on disk.
 Subsequent operations can be performed to the data in memory and written
 out to yet another different file, all without recopying the original data
 to (more) memory.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdulist.writeto('newimage.fits')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
will write the current content of 
\emph on
hdulist
\emph default
 to a new disk file 
\emph on
newfile.fits
\emph default
.
 If a file was opened with the 
\emph on
update
\emph default
 mode, the 
\emph on
flush()
\emph default
 method can also be used to write all the changes made since 
\emph on
open()
\emph default
, back to the original file.
 The 
\emph on
close()
\emph default
 method will do the same for a FITS file opened with 
\emph on
update
\emph default
 mode.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> f = pyfits.open('original.fits', mode='update') 
\end_layout

\begin_layout Standard
...
 # making changes in data and/or header 
\end_layout

\begin_layout Standard
>>> f.flush() # changes are written back to original.fits
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Create FITS Images from Scratch
\end_layout

\begin_layout Standard
So far we have demonstrated how to read and update an existing FITS file.
 But how about creating a new FITS file from scratch? Such task is very
 easy in PyFITS for an image HDU.
 We ll first demonstrate how to create a FITS file consisting only the primary
 HDU with image data.
 First, we create a numarray object for the data part:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> import numarray 
\end_layout

\begin_layout Standard
>>> n = numarray.arange(100) # a simple sequence from 0 to 99
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next, we create a 
\emph on
PrimaryHDU
\emph default
 object to encapsulate the data:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdu = pyfits.PrimaryHDU(n)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
we then create a 
\emph on
HDUList
\emph default
 to contain the newly created primary HDU, and write to a new file:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdulist = pyfits.HDUList([hdu]) 
\end_layout

\begin_layout Standard
>>> hdulist.writeto('new.fits')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That's it! In fact, PyFITS even provides a short cut for the last two lines:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdu.writeto('new.fits')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
accomplishes the same!
\end_layout

\begin_layout Subsubsection
Create FITS Tables from Scratch
\end_layout

\begin_layout Standard
To create a table HDU is a little more involved than image HDU, because
 table's structure needs more information.
 First of all, tables can only be an extension HDU, not a primary.
 There are two kinds of FITS table extensions: ASCII and binary.
 We'll use binary table examples here.
 
\end_layout

\begin_layout Standard
To create a table from scratch, we need to define columns first, by constructing
 the 
\emph on
Column
\emph default
 objects and their data.
 Say, we have two columns, the first contains strings, and the second contains
 floating point numbers
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> a1=numarray.strings.array(['NGC1001','NGC1002','NGC1003']) 
\end_layout

\begin_layout Standard
>>> a2=numarray.array([11.1,12.3,15.2]) 
\end_layout

\begin_layout Standard
>>> col1=pyfits.Column(name='target', format='20A', array=a1) 
\end_layout

\begin_layout Standard
>>> col2=pyfits.Column(name='V_mag', format='E', array=a2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Second, create a 
\emph on
ColDefs
\emph default
 (column-definitions) object for all columns:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> cols=pyfits.ColDefs([col1, col2])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, create a new binary table HDU object by using the PyFITS function 
\emph on
new_table()
\emph default
:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> tbhdu=pyfits.new_table(cols)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This function returns (in this case) a 
\emph on
BinTableHDU
\emph default
.
 Append it to the hdulist we already have:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdulist.append(tbhdu)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or create a new 
\emph on
HDUList
\emph default
 and go through the same steps as you did for the 
\emph on
ImageHDU
\emph default
.
 If this will be the only extension of the new FITS file 
\emph on
and
\emph default
 you only have a minimal primary HDU with no data, PyFITS again provides
 a short cut:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
tbhdu.writeto('table.fits')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So far, we have covered the most basic features of PyFITS.
 In the following chapters we ll show more advanced examples and explain
 options in each class and method.
\end_layout

\begin_layout Subsection
Use the Convenience Functions
\end_layout

\begin_layout Standard
PyFITS also provides several high level ("convenience") functions.
 Such a convenience function is a "canned" operation to achieve one simple
 task.
 By using these "convenience" functions, a user does not have to worry about
 opening or closing a file, all the housekeeping is done implicitly.
 
\end_layout

\begin_layout Standard
The first of these functions is 
\emph on
getheader()
\emph default
, to get the header of an HDU.
 Here are several examples of getting the header.
 Only the file name is required for this function.
 The rest of the arguments are optional and flexible to specifiy which HDU
 the user wants to get:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> getheader('in.fits') # get default HDU (=0), i.e.
 primary HDU's header 
\end_layout

\begin_layout Standard
>>> getheader('in.fits', 0) # get primary HDU's header 
\end_layout

\begin_layout Standard
>>> getheader('in.fits', 2) # the second extension
\newline

\end_layout

\begin_layout Standard
# the HDU with EXTNAME='sci' (if there is only 1) 
\end_layout

\begin_layout Standard
>>> getheader('in.fits','sci ')
\newline
 
\end_layout

\begin_layout Standard
# the HDU with EXTNAME='sci' and EXTVER=2 
\end_layout

\begin_layout Standard
>>> getheader('in.fits','sci', 2) 
\end_layout

\begin_layout Standard
>>> getheader('in.fits', ('sci', 2)) # use a tuple to do the same
\newline
 
\end_layout

\begin_layout Standard
>>> getheader('in.fits', ext=2) # the second extension
\newline
 
\end_layout

\begin_layout Standard
# the 'sci' extension, if there is only 1 
\end_layout

\begin_layout Standard
>>> getheader('in.fits', extname= 'sci' )
\newline

\end_layout

\begin_layout Standard
# the HDU with EXTNAME='sci' and EXTVER=2 
\end_layout

\begin_layout Standard
>>> getheader('in.fits', extname='sci' , extver=2)
\newline
 
\end_layout

\begin_layout Standard
# ambiguous specifications will raise an exception, DON"T DO IT!! 
\end_layout

\begin_layout Standard
>>> getheader('in.fits', ext=('sci',1), extname='err', extver=2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After you get the header, you can access the information in it, such as
 getting and modifying a keyword value:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> from pyfits import getheader 
\end_layout

\begin_layout Standard
>>> hdr = getheader('in.fits', 1) # get first extension's header 
\end_layout

\begin_layout Standard
>>> filter = hdr['filter'] # get the value of the keyword "filter
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Standard
>>> val = hdr[10] # get the 11th keyword's value 
\end_layout

\begin_layout Standard
>>> hdr['filter']= 'FW555' # change the keyword value
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For the header keywords, the header is like a dictionary, as well as a list.
 The user can access the keywords either by name or by numerix index, as
 explained earlier in this chapter.
\end_layout

\begin_layout Standard
If a user only needs to 
\emph on
read
\emph default
 one keyword, the 
\emph on
getval()
\emph default
 function can further simplify to just one call, instead of two as shown
 in the above examples:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> from pyfits import getval 
\end_layout

\begin_layout Standard
# get 1st extension's keyword FILTER's value 
\end_layout

\begin_layout Standard
>>> flt = getval('in.fits','filter', 1) 
\end_layout

\begin_layout Standard
# get the 2nd sci extension's 11th keyword's value
\end_layout

\begin_layout Standard
>>> val = getval('in.fits', 10, 'sci', 2) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function 
\emph on
getdata()
\emph default
 gets the data of an HDU.
 Similar to 
\emph on
getheader()
\emph default
, it only requires the input FITS file name while the extension is specified
 through the optional arguments.
 It does have one extra optional arguemnt 
\emph on
header
\emph default
.
 If 
\emph on
header
\emph default
 is set to True, this function will return both data and header, otherwise
 only data is returned.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> from pyfits import getdata 
\end_layout

\begin_layout Standard
>>> dat = getdata('in.fits','sci', 3) # get 3rd sci extension's data
\newline
 
\end_layout

\begin_layout Standard
# get 1st extension's data and header 
\end_layout

\begin_layout Standard
>>> data, hdr = getdata('in.fits', 1, header=True)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The functions introduced above are for reading.
 The next few functions demonstrate convenience functions for writing:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> pyfits.writeto('out.fits', data, header)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
writeto()
\emph default
 function uses the provided data and an optional header to write to an output
 FITS file.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> pyfits.append('out.fits', data, header)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
append()
\emph default
 function will use the provided data and the optional header to append to
 an existing FITS file.
 If the specified output file does not exist, it will create one.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> from pyfits import update 
\end_layout

\begin_layout Standard
>>> update(file, dat, hdr,'sci') # update the 'sci' extension 
\end_layout

\begin_layout Standard
>>> update(file, dat, 3) # update the 3rd extension 
\end_layout

\begin_layout Standard
>>> update(file, dat, hdr, 3) # update the 3rd extension 
\end_layout

\begin_layout Standard
>>> update(file, dat, 'sci' , 2) # update the 2nd SCI extension 
\end_layout

\begin_layout Standard
>>> update(file, dat, 3, header=hdr) # update the 3rd extension 
\end_layout

\begin_layout Standard
>>> update(file, dat, header=hdr, ext=5) # update the 5th extension
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The update() function will update the specified extension with the input
 data/header.
 The 3rd argument can be the header associated with the data.
 If the 3rd argument is not a header, it (and other positional arguments)
 are assumed to be the extension specification(s).
 Header and extension specs can also be keyword arguments.
 
\end_layout

\begin_layout Standard
Finally, the 
\emph on
info()
\emph default
 function will print out information of the specified FITS file:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> pyfits.info('test0.fits') 
\end_layout

\begin_layout Standard
Filename: test0.fits 
\end_layout

\begin_layout Standard
No.
 Name Type Cards Dimensions Format 
\end_layout

\begin_layout Standard
0 PRIMARY PrimaryHDU 138 () Int16 
\end_layout

\begin_layout Standard
1 SCI ImageHDU 61 (400, 400) Int16 
\end_layout

\begin_layout Standard
2 SCI ImageHDU 61 (400, 400) Int16 
\end_layout

\begin_layout Standard
3 SCI ImageHDU 61 (400, 400) Int16 
\end_layout

\begin_layout Standard
4 SCI ImageHDU 61 (400, 400) Int16
\end_layout

\end_inset


\end_layout

\begin_layout Section
FITS Headers
\end_layout

\begin_layout Standard
In the next threee chapters, more detailed information as well as examples
 will be explained for manipulating the header, the image data, and the
 table data respectively.
\end_layout

\begin_layout Subsection
Header of an HDU
\end_layout

\begin_layout Standard
Every HDU normally has two components: header and data.
 In PyFITS these two components are accessed through the two attributes
 of the HDU, 
\emph on
.header
\emph default
 and 
\emph on
.data
\emph default
.
 
\end_layout

\begin_layout Standard
While an HDU may have empty data, i.e.
 the 
\emph on
.data
\emph default
 attribute is None, any HDU will always have a header.
 When an HDU is created with a constructor, e.g.
 
\emph on
hdu=PrimaryHDU(data, header)
\emph default
, the user may supply the 
\emph on
header
\emph default
 value from an existing HDU's header and the data value from a numarray.
 If the defaults (None) are used, the new HDU will have the minimal require
 keyword:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdu = pyfits.PrimaryHDU() 
\end_layout

\begin_layout Standard
>>> print hdu.header.ascardlist() # show the keywords 
\end_layout

\begin_layout Standard
SIMPLE = T / conforms to FITS standard 
\end_layout

\begin_layout Standard
BITPIX = 8 / array data type 
\end_layout

\begin_layout Standard
NAXIS = 0 / number of array dimensions 
\end_layout

\begin_layout Standard
EXTEND = T
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A user can use any header and any data to construct a new HDU.
 PyFITS will strip the required keywords from the input header first and
 then add back the required keywords compatible to the new HDU.
 So, a user can use a table HDU's header to construct an image HDU and vice
 versa.
 The constructor will also ensure the data type and dimension information
 in the header agree with the data.
\end_layout

\begin_layout Subsection
The Header Attribute
\end_layout

\begin_layout Subsubsection
Value Access and Update
\end_layout

\begin_layout Standard
As shown in the Quick Tutorial, keyword values can be accessed via keyword
 name or index of an HDU's header attribute.
 Here is a quick summary:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdulist = pyfits.open('input.fits') # open a FITS file 
\end_layout

\begin_layout Standard
>>> prihdr = hdulist[0].header # the primary HDU header 
\end_layout

\begin_layout Standard
>>> print prihdr[3] # get the 4th keyword's value 
\end_layout

\begin_layout Standard
10 
\end_layout

\begin_layout Standard
>>> prihdr[3] = 20 # change it's value 
\end_layout

\begin_layout Standard
>>> print prihdr['darkcorr'] # get the value of the keyword 'darkcorr'
\newline
 'OMIT'
 
\end_layout

\begin_layout Standard
>>> prihdr['darkcorr']= 'PERFORM' # change darkcorr s value
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When reference by the keyword name, it is case insensitive.
 Thus, 
\emph on
prihdr['abc'], prihdr['ABC'], 
\emph default
or
\emph on
 prihdr['aBc']
\emph default
 are all equivalent.
 
\end_layout

\begin_layout Standard
A keyword (and its corresponding Card) can be deleted using the same index/name
 syntax:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> del prihdr[3] # delete the 2nd keyword 
\end_layout

\begin_layout Standard
>>> del prihdr['abc'] # get the value of the keyword 'abc' 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that, like a regular Python list, the indexing updates after each delete,
 so if 
\emph on
del prihdr[3]
\emph default
 is done two times in a row, the 2nd and 3rd keywords are removed from the
 original header.
 
\end_layout

\begin_layout Standard
Slices are not accepted by the header attribute, so it is not possible to
 do 
\emph on
del prihdr[3:5]
\emph default
, for example.
 
\end_layout

\begin_layout Standard
The method 
\emph on
update(key, value, comment)
\emph default
 is a more versatile way to update keywords.
 It has the flexibility to update an existing keyword and in case the keyword
 does not exist, add it to the header.
 It also allows the use to update both the value and its comment.
 If it is a new keyword, the user can also specify where to put it, using
 the before or after optional argument.
 The default is to append at the end of the header.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> prihdr.update('target', 'NGC1234', 'target name') 
\end_layout

\begin_layout Standard
>>> # place the next new keyword before the 'target' keyword 
\end_layout

\begin_layout Standard
>>> prihdr.update('newkey' , 666, before='target') # comment is optional
\end_layout

\begin_layout Standard
>>> # place the next new keyword after the 21st keyword 
\end_layout

\begin_layout Standard
>>> prihdr.update('newkey2', 42.0, 'another new key' , after=20)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
COMMENT, HISTORY, and Blank Keywords
\end_layout

\begin_layout Standard
Most keywords in a FITS header have unique names.
 If there are more than two cards sharing the same name, it is the first
 one accessed when referred by name.
 The duplicates can only be accessed by numeric indexing.
 
\end_layout

\begin_layout Standard
There are three special keywords (their associated cards are sometimes referred
 to as 
\emph on
commentary cards
\emph default
), which commonly appear in FITS headers more than once.
 They are (1) blank keyword, (2) HISTORY, and (3) COMMENT.
 Again, to get their values (except for the first one), a user must use
 indexing.
 
\end_layout

\begin_layout Standard
The following header methods are provided in PyFITS to add new commentary
 cards: 
\emph on
add_history(), add_comment(), and add_blank()
\emph default
.
 They are provided because the 
\emph on
update()
\emph default
 method will not work - it will replace the first card of the same keyword.
 
\end_layout

\begin_layout Standard
Users can control where in the header to add the new commentary card(s)
 by using the optional 
\emph on
before
\emph default
 and 
\emph on
after
\emph default
 arguments, similar to the 
\emph on
update()
\emph default
 method used for regular cards.
 If no 
\emph on
before
\emph default
 or 
\emph on
after
\emph default
 is specified, the new card will be placed after the last one of the same
 kind (except blank-key cards which will always be placed at the end).
 If no card of the same kind exists, it will be placed at the end.
 Here is an example:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdu.header.add_history('history 1') 
\end_layout

\begin_layout Standard
>>> hdu.header.add_blank('blank 1') 
\end_layout

\begin_layout Standard
>>> hdu.header.add_comment('comment 1') 
\end_layout

\begin_layout Standard
>>> hdu.header.add_history('history 2') 
\end_layout

\begin_layout Standard
>>> hdu.header.add_blank('blank 2') 
\end_layout

\begin_layout Standard
>>> hdu.header.add_comment('comment 2')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and the part in the modified header becomes:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
HISTORY history 1 
\end_layout

\begin_layout Standard
HISTORY history 2 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
blank 1 
\end_layout

\begin_layout Standard
COMMENT comment 1 
\end_layout

\begin_layout Standard
COMMENT comment 2 
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
\InsetSpace ~
blank 2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ironically, there is no comment in a commentary card, only a string value.
\end_layout

\begin_layout Subsection
Card Images
\end_layout

\begin_layout Standard
A FITS header consistes of 
\emph on
card images
\emph default
.
\end_layout

\begin_layout Standard
A card image in a FITS header consistes of a keyword name, a value, and
 optionally a comment.
 Physically, it takes 80 columns (bytes) - without carriage return - in
 a FITS file's storage form.
 In PyFITS, each card image is manifested by a 
\emph on
Card
\emph default
 object.
 There are also special kinds of cards: commentary cards (see above) and
 card images taking more than one 80-column card image.
 The latter will be discussed in 3.4 below.
\end_layout

\begin_layout Standard
Most of the time, a new Card object is created with the Card constructor:
 
\emph on
Card(key, value, comment)
\emph default
.
 For example:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> c1 = pyfits.Card('temp', 80.0, 'temperature, floating value') 
\end_layout

\begin_layout Standard
>>> c2 = pyfits.Card('detector', 1) # comment is optional 
\end_layout

\begin_layout Standard
>>> c3 = pyfits.Card('mir_revr', True, 'mirror reversed? Boolean value')
 >>> c4 = pyfits.Card('abc', 2+3j, 'complex value') 
\end_layout

\begin_layout Standard
>>> c5 = pyfits.Card('observer', 'Hubble', 'string value')
\newline
 
\end_layout

\begin_layout Standard
>>> print c1; print c2; print c3; print c4; print c5 # show the card images
 TEMP = 80.0 / temperature, floating value 
\end_layout

\begin_layout Standard
DETECTOR= 1 / 
\end_layout

\begin_layout Standard
MIR_REVR= T / mirror reversed? Boolean value 
\end_layout

\begin_layout Standard
ABC = (2.0, 3.0) / complex value 
\end_layout

\begin_layout Standard
OBSERVER= 'Hubble ' / string value
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cards have the attributes 
\emph on
.key, .value,
\emph default
 and 
\emph on
.comment
\emph default
.
 Both 
\emph on
.value
\emph default
 and 
\emph on
.commet
\emph default
 can be changed but not the 
\emph on
.key
\emph default
 attribute.
 
\end_layout

\begin_layout Standard
The 
\emph on
Card()
\emph default
 constructor will check if the arguments given are conforming to the FITS
 standard and has a fixed card image format.
 If the user wants to create a card with a customized format or even a card
 which is not conforming to the FITS standard (e.g.
 for testing purposes), the card method 
\emph on
fromstring()
\emph default
 can be used.
 
\end_layout

\begin_layout Standard
Cards can be verified by the 
\emph on
verify()
\emph default
 method.
 The non-standard card c2 in the example below, is flagged by such verification.
 More about verification in PyFITS will be discussed in Chapter 6.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> c1 = pyfits.Card().fromstring('ABC = 3.456D023') 
\end_layout

\begin_layout Standard
>>> c2 = pyfits.Card().fromstring("P.I.
 = 'Hubble'") 
\end_layout

\begin_layout Standard
>>> print c1; print c2 
\end_layout

\begin_layout Standard
ABC = 3.456D023 
\end_layout

\begin_layout Standard
P.I.
 = 'Hubble' 
\end_layout

\begin_layout Standard
>>> c2.verify() 
\end_layout

\begin_layout Standard
Output verification result: 
\end_layout

\begin_layout Standard
Unfixable error: Illegal keyword name 'P.I.' 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Card List
\end_layout

\begin_layout Standard
The Header itself only has limited functionalities.
 Many lower level operations can only be achieved by going through its 
\emph on
CardList
\emph default
 object.
 
\end_layout

\begin_layout Standard
The header is basically a list of Cards.
 This list can be manifested as a 
\emph on
CardList
\emph default
 object in PyFITS.
 It is accessed via the 
\emph on
ascardlist()
\emph default
 method (or the 
\emph on
.ascard
\emph default
 attribute, for short) of Header.
 Since the header attribute only refers to a card value, so when a user
 needs to access a card's other properties (e.g.
 the comment) in a header, it has to go through the CardList.
 Like the header's item, the CardList's item can be accessed through either
 the keyword name or index.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> cards = prihdr.header.ascardlist() 
\end_layout

\begin_layout Standard
>>> cards['abc'].comment='new comment' # update the keyword ABC's comment
 
\end_layout

\begin_layout Standard
>>> cards[3].key # see the keyword name of the 4th card 
\end_layout

\begin_layout Standard
>>> cards[10:20].keys() # see keyword names from cards 11 to 20
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
CONTINUE Cards
\end_layout

\begin_layout Standard
The fact that the FITS standard only allows up to 8 characters for the keyword
 name and 80 characters to contain the keyword, the value, and the comment
 is restrictive for certain applications.
 To allow long string values for keywords, a proposal was made in:
\newline

\end_layout

\begin_layout Standard
http://legacy.gsfc.nasa.gov/docs/heasarc/ofwg/docs/ofwg_recomm/r13.html
\newline

\end_layout

\begin_layout Standard
by using the CONTINUE keyword after the regular 80-column containing the
 keyword.
 PyFITS does support this convention, even though it is not a FITS standard.
 The examples below show the use of CONTINUE is automatic for long string
 values.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> c=pyfits.Card( abc , abcdefg *20) 
\end_layout

\begin_layout Standard
>>> print c 
\end_layout

\begin_layout Standard
ABC = 'abcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcd&'
 CONTINUE 'efgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefga&'
 CONTINUE 'bcdefg&'
\end_layout

\begin_layout Standard
>>> c.value
\end_layout

\begin_layout Standard
'abcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgab
cdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefg'
\newline

\newline
 # both value
 and comments are long 
\end_layout

\begin_layout Standard
>>> c=pyfits.Card( abc , abcdefg *10, abcdefg *10) 
\end_layout

\begin_layout Standard
>>> print c 
\end_layout

\begin_layout Standard
ABC = 'abcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcd&'
 CONTINUE 'efg&'
\end_layout

\begin_layout Standard
CONTINUE '&' /
\end_layout

\begin_layout Standard
abcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefga
\end_layout

\begin_layout Standard
CONTINUE '&' / bcdefg
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that when CONTINUE card is used, at the end of each 80-characters card
 image, an ampersand is present.
 The ampersand is not part of the string value.
 Also, there is no "=" at the 9th column after CONTINUE.
 In the first example, the entire 240 characters is considered a Card.
 So, if it is the nth card in a header, the (n+1)th card refers to the next
 keyword, not the 80-characters containing CONTINUE.
 These keywords having long string values can be accessed and updated just
 like regular keywords.
\end_layout

\begin_layout Subsection
HIERARCH Cards
\end_layout

\begin_layout Standard
For keywords longer than 8 characters, there is a convention originated
 at ESO to facilitate such use.
 It uses a special keyword HIERARCH with the actual long keyword following.
 PyFITS supports this convention as well.
 
\end_layout

\begin_layout Standard
When creating or updating using the header.update() method, it is
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> c = pyfits.Card('abcdefghi',10) 
\end_layout

\begin_layout Standard
...
 
\end_layout

\begin_layout Standard
ValueError: keyword name abcdefghi is too long (> 8), use HIERARCH.
\newline
 
\end_layout

\begin_layout Standard
>>> c=pyfits.Card('hierarch abcdefghi',10) 
\end_layout

\begin_layout Standard
>>> print c HIERARCH abcdefghi = 10 
\newline

\end_layout

\begin_layout Standard
>>> h=pyfits.PrimaryHDU() 
\end_layout

\begin_layout Standard
>>> h.header.update('hierarch abcdefghi', 99)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
necessary to prepend 'hierarch' (case insensitive).
 But if the keyword is already in the header, it can be accessed or updated
 by assignment by using the keyword name diretly, with or without the 'hierarch'
 prepending.
 The
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> h.header.update('hierarch abcdefghi', 99) 
\end_layout

\begin_layout Standard
>>> h.header['abcdefghi'] 
\end_layout

\begin_layout Standard
99 
\end_layout

\begin_layout Standard
>>> h.header['abcdefghi']=10 
\end_layout

\begin_layout Standard
>>> h.header['hierarch abcdefghi' ] 
\end_layout

\begin_layout Standard
10
\newline
 
\end_layout

\begin_layout Standard
# case insensitive 
\end_layout

\begin_layout Standard
--> h.header.update('hierarch ABCdefghi', 1000) 
\end_layout

\begin_layout Standard
--> print h.header 
\end_layout

\begin_layout Standard
SIMPLE = T / conforms to FITS standard 
\end_layout

\begin_layout Standard
BITPIX = 8 / array data type 
\end_layout

\begin_layout Standard
NAXIS = 0 / number of array dimensions 
\end_layout

\begin_layout Standard
EXTEND = T 
\end_layout

\begin_layout Standard
HIERARCH ABCdefghi = 1000 
\end_layout

\begin_layout Standard
--> h.header['hierarch abcdefghi'] 
\end_layout

\begin_layout Standard
1000
\end_layout

\end_inset


\end_layout

\begin_layout Standard
keyword name will preserve its cases from its constructor, but when refer
 to the keyword, it is case insensitive.
\end_layout

\begin_layout Section
Image Data
\end_layout

\begin_layout Standard
In this chapter, we'll discuss the data component in an image HDU.
\end_layout

\begin_layout Subsection
Image Data as an Array
\end_layout

\begin_layout Standard
A FITS primary HDU or an image extension HDU may contain image data.
 The following discussions apply to both of these HDU classes.
 In PyFITS, for most cases, it is just a simple numarray, having the shape
 specified by the NAXIS keywords and the data type specified by the BITPIX
 keyword - unless the data is scaled, see next section.
 Here is a quick cross reference between allowed BITPIX values in FITS images
 and the numarray data types:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
BITPIX numarray data type 
\newline

\end_layout

\begin_layout Standard
8 UInt8 (note it is UNsigned integer) 
\end_layout

\begin_layout Standard
16 Int16 
\end_layout

\begin_layout Standard
32 Int32 
\end_layout

\begin_layout Standard
-32 Float32 
\end_layout

\begin_layout Standard
-64 Float64
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To recap the fact that in numarray the arrays are 0-indexed and the axes
 are ordered from slow to fast.
 So, if a FITS image has NAXIS1=300 and NAXIS2=400, the numarray of its
 data will have the shape of (400, 300).
 Here is a summary of reading and updating image data values:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> f = pyfits.open(
\begin_inset Quotes eld
\end_inset

image.fits
\begin_inset Quotes erd
\end_inset

) # open a FITS file 
\end_layout

\begin_layout Standard
>>> scidata = f[1].data # assume the first extension is an image 
\end_layout

\begin_layout Standard
>>> print scidata[1,4] # get the pixel value at x=5, y=2 
\end_layout

\begin_layout Standard
>>> scidata[30:40, 10:20] # get values of the subsection from x=11 to 20,
 y=31 to 40 (inclusive) 
\end_layout

\begin_layout Standard
>>> scidata[1,4] = 999 # update a pixel value 
\end_layout

\begin_layout Standard
>>> scidata[30:40, 10:20] = 0 # update values of a subsection 
\end_layout

\begin_layout Standard
>>> scidata[3] = scidata[2] # copy the 3rd row to the 4th row
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here are some more complicated examples by using the concept of the "mask
 array".
 The first example is to change all negative pixel values in scidata to
 zero.
 The second one is to take logarithm of the pixel values which are positive:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> scidata[scidata<0] = 0 
\end_layout

\begin_layout Standard
>>> scidata[scidata>0] = numarray.log(scidata[scidata>0])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These examples show the concise nature of numarray operations.
\end_layout

\begin_layout Subsection
Scaled Data
\end_layout

\begin_layout Standard
Sometimes an image is scaled, i.e.
 the data stored in the file is not the image s physical (true) values,
 but linearly transformed according to the equation:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
physical value = BSCALE*(storage value) + BZERO
\end_layout

\end_inset


\end_layout

\begin_layout Standard
BSCALE and BZERO are stored as keywords of the same names in the header
 of the same HDU.
 The most common use of scaled image is to store unsigned 16-bit integer
 data because FITS standard does not allow it.
 In this case, the stored data is signed 16-bit integer (BITPIX=16) with
 BZERO=32768 (2**15), BSCALE=1.
\end_layout

\begin_layout Subsubsection
Reading Scaled Image Data
\end_layout

\begin_layout Standard
Images are scaled only when either of the BSCALE/BZERO keywords are present
 in the header and either of their values is not the default value (BSCALE=1,
 BZERO=0).
\end_layout

\begin_layout Standard
For unscaled data, the data attribute of an HDU in PyFITS is a numarray
 of the same data type as specified by the BITPIX keyword.
 For scaled image, the 
\emph on
.data
\emph default
 attribute will be the 
\emph on
physical data
\emph default
, i.e.
 already transformed from the 
\emph on
storage
\emph default
 data and may not be the same data type as prescribed in BITPIX.
 This means an extra step of copying is needed and thus the corresponding
 memory requirement.
 This also means that the advantage of memory mapping is reduced for scaled
 data.
 
\end_layout

\begin_layout Standard
For floating point storage data, the scaled data will have the same data
 type.
 For integer data type, the scaled data will always be single precision
 floating point (Float32).
 Here is an example of what happens to such a file, before and after the
 data is touched:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> f=pyfits.open( scaled_uint16.fits ) 
\end_layout

\begin_layout Standard
>>> hdu = f[1] 
\end_layout

\begin_layout Standard
>>> print hdu.header[ bitpix ], hdu.header[ bzero ] 
\end_layout

\begin_layout Standard
16 32768 
\end_layout

\begin_layout Standard
>>> print hdu.data # once data is touched, it is scaled 
\end_layout

\begin_layout Standard
[ 11.
 12.
 13.
 14.
 15.] 
\end_layout

\begin_layout Standard
>>> hdu.data.type() 
\end_layout

\begin_layout Standard
Float32 
\end_layout

\begin_layout Standard
>>> print hdu.header[ bitpix ] # BITPIX is also updated 
\end_layout

\begin_layout Standard
-32 
\end_layout

\begin_layout Standard
# BZERO and BSCALE are removed after the scaling 
\end_layout

\begin_layout Standard
>>> print hdu.header[ bzero ] 
\end_layout

\begin_layout Standard
KeyError: "Keyword 'bzero' not found."
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Writing Scaled Image Data
\end_layout

\begin_layout Standard
With the extra processing and memory requirement, we discourage users to
 use scaled data as much as possible.
 However, PyFITS does provide ways to write scaled data with the 
\emph on
scale(type, option, bscale, bzero)
\emph default
 method.
 Here are a few examples:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
# scale the data to Int16 with user specified bscale/bzero 
\end_layout

\begin_layout Standard
>>> hdu.scale('Int16', '', bzero=32768) 
\newline

\end_layout

\begin_layout Standard
# scale the data to Int32 with the min/max of the data range 
\end_layout

\begin_layout Standard
>>> hdu.scale('Int32','minmax') 
\newline

\end_layout

\begin_layout Standard
# scale the data, using the original BSCALE/BZERO 
\end_layout

\begin_layout Standard
>>> hdu.scale('Int32','old')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first example above shows how to store an unsigned short integer array.
 
\end_layout

\begin_layout Standard
Great caution must be exercised when using the 
\emph on
scale()
\emph default
 method.
 The 
\emph on
.data
\emph default
 attribute of an image HDU, after the 
\emph on
scale()
\emph default
 call, will become the storage values, not the physical values.
 So, only call 
\emph on
scale()
\emph default
 just before writing out to FITS files, i.e.
 calls of 
\emph on
writeto(), flush(), 
\emph default
or 
\emph on
close()
\emph default
.
 No further use of the data should be exercised.
 Here is an example of what happens to the 
\emph on
.data
\emph default
 attribute after the 
\emph on
scale()
\emph default
 call:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdu=pyfits.PrimaryHDU(numarray.array([0.,1,2,3])) 
\end_layout

\begin_layout Standard
>>> print hdu.data 
\end_layout

\begin_layout Standard
[ 0.
 1.
 2.
 3.] 
\end_layout

\begin_layout Standard
>>> hdu.scale('Int16', '', bzero=32768) 
\end_layout

\begin_layout Standard
>>> print hdu.data # now the data has storage values 
\end_layout

\begin_layout Standard
[-32768 -32767 -32766 -32765] 
\end_layout

\begin_layout Standard
>>> hdu.writeto('new.fits')
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Data Section
\end_layout

\begin_layout Standard
When a FITS image HDU's 
\emph on
.data
\emph default
 is accessed, either the whole data is copied into memory (in cases of NOT
 using memory mapping or if the data is scaled) or a virtual memory space
 equivalent to the data size is allocated (in the case of memory mapping
 of non-scaled data).
 If there are several very large image HDU's being accessed at the same
 time, the system may run out of memory.
 
\end_layout

\begin_layout Standard
If a user does not need the entire image(s) at the same time, e.g.
 processing images(s) ten rows at a time, the 
\emph on
section()
\emph default
 method can be used to alleviate such memory problems.
 
\end_layout

\begin_layout Standard
Here is an example of getting the median image from 3 input images of the
 size 5000x5000:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> f1=pyfits.open('file1.fits') 
\end_layout

\begin_layout Standard
>>> f2=pyfits.open('file2.fits') 
\end_layout

\begin_layout Standard
>>> f3=pyfits.open('file3.fits') 
\end_layout

\begin_layout Standard
>>> output = numarray.zeros(5000*5000) 
\end_layout

\begin_layout Standard
>>> for i in range(50): 
\end_layout

\begin_layout Standard
...
 j=i*100 
\end_layout

\begin_layout Standard
...
 k=j+100 
\end_layout

\begin_layout Standard
...
 x1=f[1].section[j:k,:] 
\end_layout

\begin_layout Standard
...
 x2=f[2].section[j:k,:] 
\end_layout

\begin_layout Standard
...
 x3=f[3].section[j:k,:] 
\end_layout

\begin_layout Standard
...
 # use numarray.image s median function 
\end_layout

\begin_layout Standard
...
 output[j:k] = numarray.image.median([x1,x2,x3])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Data in each 
\emph on
.section
\emph default
 must be contiguous.
 Therefore, if 
\emph on
f[1].data
\emph default
 is a 400x400 image, the first part of the following specifications will
 not work, while the second part will:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> # These will NOT work, since the data are not contiguous! 
\end_layout

\begin_layout Standard
>>> f[1].section[:5,:5] 
\end_layout

\begin_layout Standard
>>> f[1].section[:,:3] 
\end_layout

\begin_layout Standard
>>> f[1].section[:,2] 
\newline

\end_layout

\begin_layout Standard
>>> # but these will work: 
\end_layout

\begin_layout Standard
>>> f[1].section[5,:] 
\end_layout

\begin_layout Standard
>>> f[1].section[5,:10] 
\end_layout

\begin_layout Standard
>>> f[1].section[6,7]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
At present, the 
\emph on
section()
\emph default
 method does not support scaled data.
\end_layout

\begin_layout Section
Table Data
\end_layout

\begin_layout Standard
In this chapter, we'll discuss the data component in a table HDU.
 A table will always be in an extension HDU, never in a primary HDU.
 
\end_layout

\begin_layout Standard
There are two kinds of tables in the FITS standard: a binary table and an
 ASCII table.
 A binary table is more economical in storage and faster in data access
 and manipulation.
 An ASCII table stores the data in a "human readable" form and therefore
 takes up more storage space as well as more processing time since the ASCII
 text needs to be parsed back into numerical values.
\end_layout

\begin_layout Subsection
Table Data as a Record Array
\end_layout

\begin_layout Subsubsection
What is a Record Array?
\end_layout

\begin_layout Standard
A record array is an array which contains records (i.e.
 rows) of heterogeneous data types.
 Record array is available through the 
\emph on
records
\emph default
 module in the 
\emph on
numarray
\emph default
 library.
 Here is a simple example of record array:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> import numarray.records as rec 
\end_layout

\begin_layout Standard
>>> bright=rec.array([(1, 'Sirius' , -1.45, 'A1V' ),
\backslash
 
\end_layout

\begin_layout Standard
...
 (2, 'Canopus' , -0.73, 'F0Ib' ),
\backslash
 
\end_layout

\begin_layout Standard
...
 (3, 'Rigil Kent' , -0.1, 'G2V' )],
\backslash
 
\end_layout

\begin_layout Standard
...
 formats= 'Int16,a20,Float32,a10',
\backslash
 
\end_layout

\begin_layout Standard
...
 names= 'order,name,mag,Sp' )
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this example, there are 3 records (rows) and 4 fields (columns).
 The first field is a short integer, second a character string (of length
 20), third a floating point number, and fourth a character string (of length
 10).
 Each record has the same (heterogeneous) data structure.
\end_layout

\begin_layout Subsubsection
Metadata of a Table
\end_layout

\begin_layout Standard
The data in a FITS table HDU is basically a record array, with added attributes.
 The metadata, i.e.
 information about the table data, are stored in the header.
 For example, the keyword TFORM1 contains the format of the first field,
 TTYPE2 the name of the second field, etc.
 NAXIS2 gives the number of records(rows) and TFIELDS gives the number of
 fields (columns).
 For FITS tables, the maximum number of fields is 999.
 The data type specified in TFORM is represented by letter code for binary
 tables and a FORTRAN-like format string for ASCII tables.
 Note that this is different from the format specifications when constructing
 a record array.
\end_layout

\begin_layout Subsubsection
Reading a FITS Table
\end_layout

\begin_layout Standard
Like images, the 
\emph on
.data
\emph default
 attribute of a table HDU contains the data of the table.
 To recap the simple example in Chapter 1:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> f = pyfits.open('bright_stars.fits') # open a FITS file 
\end_layout

\begin_layout Standard
>>> tbdata = f[1].data # assume the first extension is a table 
\end_layout

\begin_layout Standard
>>> print tbdata[:2] # show the first two rows 
\end_layout

\begin_layout Standard
RecArray[ 
\end_layout

\begin_layout Standard
(1, 'Sirius' , -1.4500000476837158, 'A1V' ), 
\end_layout

\begin_layout Standard
(2, 'Canopus' , -0.73000001907348633, 'F0Ib' ) 
\end_layout

\begin_layout Standard
] 
\end_layout

\begin_layout Standard
--> print tbdata.field('mag') # show the values in field "mag" 
\end_layout

\begin_layout Standard
[-1.45000005 -0.73000002 -0.1 ] 
\end_layout

\begin_layout Standard
--> print tbdata.field(1) # field can be referred by index too 
\end_layout

\begin_layout Standard
[ 'Sirius' 'Canopus' 'Rigil' 'Kent' ] 
\newline

\end_layout

\begin_layout Standard
>>> scidata[1,4] = 999 # update a pixel value 
\end_layout

\begin_layout Standard
>>> scidata[30:40, 10:20] = 0 # update values of a subsection 
\end_layout

\begin_layout Standard
>>> scidata[3] = scidata[2] # copy the 3rd row to the 4th row
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that in PyFITS, when using the 
\emph on
field()
\emph default
 method, it is 0-indexed while the suffixes in header keywords, such as
 TFORM is 1-indexed.
 So, 
\emph on
tbdata.field(0)
\emph default
 is the data in the column with the name specified in TTYPE1 and format
 in TFORM1.
\end_layout

\begin_layout Subsection
Table Operations
\end_layout

\begin_layout Subsubsection
Select Records in a Table
\end_layout

\end_body
\end_document
